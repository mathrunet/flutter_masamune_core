part of masamune.model;

/// Data model for storing single-shot data such as String, int, and double.
///
/// Please inherit and use it.
///
/// ```
/// class TestField extends FieldModel {
///   TestField() : super("field");
///   FutureOr build(ModelContext context) {
///     return "Text";
///   }
/// }
/// ```
///
/// You can rewrite the value with [set], [increment], [decrement], etc., and get a value of the type with [getString], etc.
/// You can also get the value by [dynamic] by specifying [value].
abstract class FieldModel extends Model<dynamic, IDataField>
    with
        PathModelMixin<dynamic, IDataField>,
        ClonableModelMixin<dynamic, IDataField>
    implements IDataField {
  /// Data model for storing single-shot data such as String, int, and double.
  ///
  /// Please inherit and use it.
  ///
  /// ```
  /// class TestField extends FieldModel {
  ///   TestField() : super("field");
  ///   FutureOr build(ModelContext context) {
  ///     return "Text";
  ///   }
  /// }
  /// ```
  ///
  /// You can rewrite the value with [set], [increment], [decrement], etc., and get a value of the type with [getString], etc.
  /// You can also get the value by [dynamic] by specifying [value].
  FieldModel(String path) : super(path);

  /// Converts a value to an object in path format.
  ///
  /// In [createdValue], the data generated by [build] is stored.
  ///
  /// Finally, by storing it in an object of [IPath] format,
  /// it can be obtained by [state].
  @override
  @protected
  FutureOr<IDataField> exposeValue(FutureOr createdValue) {
    if (createdValue is Future) {
      return createdValue.then((value) {
        if (value is IDataField) {
          if (value.path == this.path) {
            return value;
          } else {
            return value.clone(path: this.path);
          }
        } else {
          return DataField(this.path, value);
        }
      });
    } else {
      if (createdValue is IDataField) {
        if (createdValue.path == this.path) {
          return createdValue;
        } else {
          return createdValue.clone(path: this.path);
        }
      } else {
        return DataField(this.path, createdValue);
      }
    }
  }

  /// You can set and rewrite the data.
  ///
  /// You can pass any value you want to set to [value].
  ///
  /// It is possible to set a new value by specifying a separate [builder] to use the initial value, or if it already exists, to use that value.
  void set(dynamic value, [dynamic builder(dynamic value)]) {
    final state = this.state;
    if (builder == null) {
      if (state == null) {
        DataField(this.path, value);
      } else {
        state.data = value;
      }
    } else {
      if (state == null) {
        DataField(this.path, builder(value));
      } else {
        state.data = builder(state.data ?? value);
      }
    }
  }

  /// If the value of a field is numeric, you can increase its value by [value].
  void increment([num value = 1]) {
    if (value == null) return;
    final state = this.state;
    if (state == null) {
      DataField(this.path, value);
    } else {
      if (value is int) state.data = state.getInt() + value;
      if (value is double) state.data = state.getDouble() + value;
    }
  }

  /// If the value of a field is numeric, you can decrease its value by [value].
  void decrement([num value = 1]) {
    if (value == null) return;
    final state = this.state;
    if (state == null) {
      DataField(this.path, -value);
    } else {
      if (value is int) state.data = state.getInt() - value;
      if (value is double) state.data = state.getDouble() - value;
    }
  }

  /// Get the data set in the field.
  dynamic get value {
    final state = this.state;
    if (state == null) return null;
    return state.data;
  }

  /// Set the specified [value] in the field.
  set value(dynamic value) {
    final state = this.state;
    if (state == null) return;
    state.data = value;
  }

  /// Get the data set in the field as [bool].
  ///
  /// You can pass an initial value to [defaultValue] if the data does not exist.
  bool getBool([bool defaultValue = false]) {
    final state = this.state;
    if (state == null) return defaultValue;
    return state.getBool(defaultValue);
  }

  /// Get the data set in the field as [int].
  ///
  /// You can pass an initial value to [defaultValue] if the data does not exist.
  int getInt([int defaultValue = 0]) {
    final state = this.state;
    if (state == null) return defaultValue;
    return state.getInt(defaultValue);
  }

  /// Get the data set in the field as [double].
  ///
  /// You can pass an initial value to [defaultValue] if the data does not exist.
  double getDouble([double defaultValue = 0]) {
    final state = this.state;
    if (state == null) return defaultValue;
    return state.getDouble(defaultValue);
  }

  /// Get the data set in the field as [String].
  ///
  /// You can pass an initial value to [defaultValue] if the data does not exist.
  String getString([String defaultValue = ""]) {
    final state = this.state;
    if (state == null) return defaultValue;
    return state.getString(defaultValue);
  }

  /// Get the data set in the field as [List].
  ///
  /// You can pass an initial value to [defaultValue] if the data does not exist.
  List<V> getList<V extends Object>([List defaultValue = const []]) {
    final state = this.state;
    if (state == null) return defaultValue;
    return state.getList<V>(defaultValue);
  }

  /// Get the data set in the field as [Map].
  ///
  /// You can pass an initial value to [defaultValue] if the data does not exist.
  Map<K, V> getMap<K extends Object, V extends Object>(
      [Map defaultValue = const {}]) {
    final state = this.state;
    if (state == null) return defaultValue;
    return state.getMap<K, V>(defaultValue);
  }

  /// Get the data set in the field as [GeoData].
  ///
  /// You can pass an initial value to [defaultValue] if the data does not exist.
  T getGeo<T extends GeoData>([T defaultValue]) {
    final state = this.state;
    if (state == null) return defaultValue;
    return state.getGeo<T>(defaultValue);
  }

  @override
  Object get data {
    final state = this.state;
    if (state == null) return null;
    return state.data;
  }

  @override
  set data(Object data) {
    final state = this.state;
    if (state == null) return;
    state.data = data;
  }

  @override
  operator [](String path) {
    final state = this.state;
    if (state == null) return null;
    return state[path];
  }

  @override
  T debug<T extends IDebuggable>([Object value]) {
    final state = this.state;
    if (state == null) return null;
    return state.debug(value);
  }

  @override
  @protected
  void setInternal(Object value) {
    final state = this.state;
    if (state == null) return;
    state.setInternal(value);
  }

  @override
  void unsetInternal() {
    final state = this.state;
    if (state == null) return;
    state.unsetInternal();
  }

  @override
  bool get isLock {
    final state = this.state;
    if (state == null) return null;
    return state.isLock;
  }

  @override
  @protected
  Object get rawData {
    final state = this.state;
    if (state == null) return null;
    return state.rawData;
  }
}
