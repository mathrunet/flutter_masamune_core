part of masamune.model;

/// Create a data model that treats the data as a collection.
///
/// Please inherit and use it.
///
/// ```
/// class TestCollection extends CollectionModel {
///   TestCollection() : super("collection");
///   FutureOr build(ModelContext context) {
///     return [
///       {
///         "name": "Name",
///         "age": 19,
///         "sex": "female",
///       },
///       {
///         "name": "Name",
///         "age": 19,
///         "sex": "female"
///       }
///     ];
///   }
/// }
/// ```
///
/// Collections have an ordered array of data structures, such as [List].
/// Basically, you can use [for] statements and various [Iterable] methods to retrieve data.
///
/// In the [build] method of a widget, you can use [map] or [expand] in combination with [ListView], [Column], [Row] and other widgets to create a more visible structure.
abstract class CollectionModel
    extends Model<List<Map<String, dynamic>>, IDataCollection>
    with
        IterableMixin<IDataDocument>,
        PathModelMixin<List<Map<String, dynamic>>, IDataCollection>,
        ClonableModelMixin<List<Map<String, dynamic>>, IDataCollection>
    implements IDataCollection {
  final OrderBy orderBy;
  final OrderBy thenBy;
  final String orderByKey;
  final String thenByKey;

  /// Create a data model that treats the data as a collection.
  ///
  /// By specifying [path], you can get data from [PathMap] as well, and you can get the data even outside of the build timing.
  ///
  /// You can sort by specifying [orderBy], [orderByKey].
  /// You can also specify [thenBy] and [thenByKey] to further sort the elements in the same order in the first sort.
  CollectionModel(
      {this.orderBy = OrderBy.none,
      this.orderByKey,
      this.thenBy = OrderBy.none,
      this.thenByKey})
      : super();

  /// Converts a value to an object in path format.
  ///
  /// In [createdValue], the data generated by [build] is stored.
  ///
  /// Finally, by storing it in an object of [IPath] format,
  /// it can be obtained by [state].
  @override
  @protected
  FutureOr<IDataCollection> exposeValue(FutureOr createdValue) {
    if (createdValue is Future) {
      return createdValue.then((value) {
        if (value is IDataCollection) {
          return value;
        } else if (value is List<Map<String, dynamic>>) {
          return TempCollection.fromList(value);
        } else {
          return TempCollection.fromList(<Map<String, dynamic>>[]);
        }
      });
    } else if (createdValue is IDataCollection) {
      return createdValue;
    } else if (createdValue is List<Map<String, dynamic>>) {
      return TempCollection.fromList(createdValue);
    } else {
      return TempCollection.fromList(<Map<String, dynamic>>[]);
    }
  }

  /// If no object is found, an empty object is created.
  @override
  @protected
  IDataCollection emptyValue() => TempCollection();

  /// Get the iterator of the collection.
  @override
  Iterator<IDataDocument> get iterator =>
      this.state?.iterator ?? <IDataDocument>[].iterator;

  /// Removes documents from the collection that are located at the specified [key].
  ///
  /// Include and delete documents that have data on the server.
  Future delete(Object key) async {
    final state = this.state;
    if (state == null) return;
    if (state is IDataCollection) {
      await state[key]?.delete();
    } else if (state is CollectionModel) {
      await state.delete(key);
    }
  }

  /// Reload the collection data.
  Future<T> reload<T extends IDataCollection>() {
    final state = this.state;
    if (state == null) return Future.delayed(Duration.zero);
    return state.reload<T>();
  }

  /// Load the following data.
  Future<T> next<T extends IDataCollection>() {
    final state = this.state;
    if (state == null) return Future.delayed(Duration.zero);
    return state.next<T>();
  }

  /// True if the following data is available.
  bool canNext() {
    final state = this.state;
    if (state == null) return false;
    if (state is IDataCollection) {
      return state.canNext();
    } else if (state is CollectionModel) {
      return state.canNext();
    }
    return false;
  }

  @override
  IDataCollection operator +(IDataDocument<IDataField> value) {
    final state = this.state;
    if (state == null) return null;
    state.add(value);
    return state;
  }

  @override
  IDataCollection operator -(IDataDocument<IDataField> value) {
    final state = this.state;
    if (state == null) return null;
    state.remove(value);
    return state;
  }

  @override
  IDataDocument operator [](Object key) {
    final state = this.state;
    if (state == null) return null;
    return state[key];
  }

  @override
  void add(IDataDocument child) {
    final state = this.state;
    if (state == null) return;
    state.add(child);
  }

  @override
  void addAll(Iterable<IDataDocument> children) {
    final state = this.state;
    if (state == null) return;
    state.addAll(children);
  }

  @override
  void clear() {
    final state = this.state;
    if (state == null) return;
    state.clear();
  }

  @override
  bool containsID(String id) {
    final state = this.state;
    if (state == null) return false;
    return state.containsID(id);
  }

  @override
  bool containsPath(String path) {
    final state = this.state;
    if (state == null) return false;
    return state.containsPath(path);
  }

  @override
  @protected
  SortedMap<String, IDataDocument> get data {
    final state = this.state;
    if (state == null) return null;
    return state.data;
  }

  @override
  T debug<T extends IDebuggable>([Object value]) {
    final state = this.state;
    if (state == null) return null;
    return state.debug(value);
  }

  @override
  bool get isLock {
    final state = this.state;
    if (state == null) return null;
    return state.isLock;
  }

  @override
  void remove(IDataDocument child) {
    final state = this.state;
    if (state == null) return;
    state.remove(child);
  }

  @override
  void removeAll(Iterable<IDataDocument<IDataField>> children) {
    final state = this.state;
    if (state == null) return;
    state.removeAll(children);
  }

  @override
  void removeAt(int index) {
    final state = this.state;
    if (state == null) return;
    state.removeAt(index);
  }

  @override
  void removeBy(String key) {
    final state = this.state;
    if (state == null) return;
    state.removeBy(key);
  }

  @override
  void removeWhere(bool Function(IDataDocument child) predicate) {
    final state = this.state;
    if (state == null) return;
    state.removeWhere(predicate);
  }

  @override
  @protected
  void set(Iterable<IDataDocument> children) {
    final state = this.state;
    if (state == null) return;
    state.set(children);
  }

  @override
  @protected
  void setInternal(IDataDocument value) {
    final state = this.state;
    if (state == null) return;
    state.setInternal(value);
  }

  @override
  void sort() {
    final state = this.state;
    if (state == null) return;
    state.sort();
  }

  @override
  Map<String, dynamic> toJson() {
    final state = this.state;
    if (state == null) return <String, dynamic>{};
    return state.toJson();
  }

  @override
  void unsetInternal(IDataDocument value) {
    final state = this.state;
    if (state == null) return;
    state.unsetInternal(value);
  }
}
